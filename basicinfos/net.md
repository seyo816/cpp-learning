#### 基础工具安装
```
#基础插件
yum -y install lrzsz screen tree git unzip wget
yum install epel-release -y #先安装epel源
yum install python-pip -y #然后就可以通过yum install python-X来安装python的X库了
pip install --upgrade pip #升级pip到最新版本

#监控工具
yum -y install iotop sysstat htop iftop strace

#编译工具
yum -y install automake cmake  autoconf  libtool make

#安装多版本GCC:GCC4.9，GCC5.3，GCC6.2
yum -y install centos-release-scl-rh
#yum install devtoolset-3-gcc devtoolset-3-gcc-c++
#yum install devtoolset-4-gcc devtoolset-4-gcc-c++
yum -y install devtoolset-6-gcc devtoolset-6-gcc-c++
#source /opt/rh/devtoolset-3/enable
#source /opt/rh/devtoolset-4/enable
source /opt/rh/devtoolset-6/enable

# 网络工具
yum -y install bridge-utils
yum install net-tools
yum install iproute
yum install mtr # brew install mtr
yum install traceroute

#安装ip地址显示版本
git clone https://github.com/dzxx36gyy/nali-ipip.git
cd nali-ipip
chmod 777 configure && ./configure && make && make install

```

#### 测试网络命令
```
nali-mtr -r -c 10 -n www.baidu.com

```


#### ip
```
http://tonybai.com/2016/01/15/understanding-container-networking-on-single-host/?utm_source=tuicool&utm_medium=referral

// 网桥
$ brctl show
// 网络设备
$ ip link show
// 网络设备ip地址
$ ip addr show
//
ip route


[root@iZ2ze1jcv568atyng0q3fcZ ~]# ip link show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000
    link/ether 00:16:3e:03:f4:46 brd ff:ff:ff:ff:ff:ff
3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DEFAULT
    link/ether 02:42:16:a1:27:0b brd ff:ff:ff:ff:ff:ff
15: veth920d8aa@if14: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT
    link/ether 1e:f9:51:76:7d:e3 brd ff:ff:ff:ff:ff:ff link-netnsid 0
[root@iZ2ze1jcv568atyng0q3fcZ ~]# ip addr show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:16:3e:03:f4:46 brd ff:ff:ff:ff:ff:ff
    inet 172.17.174.68/20 brd 172.17.175.255 scope global eth0
       valid_lft forever preferred_lft forever
3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP
    link/ether 02:42:16:a1:27:0b brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.1/16 scope global docker0
       valid_lft forever preferred_lft forever
15: veth920d8aa@if14: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP
    link/ether 1e:f9:51:76:7d:e3 brd ff:ff:ff:ff:ff:ff link-netnsid 0
[root@iZ2ze1jcv568atyng0q3fcZ ~]# ip route
default via 172.17.175.253 dev eth0
169.254.0.0/16 dev eth0  scope link  metric 1002
172.17.160.0/20 dev eth0  proto kernel  scope link  src 172.17.174.68
172.18.0.0/16 dev docker0  proto kernel  scope link  src 172.18.0.1


cat /etc/sysconfig/iptables
# Generated by iptables-save v1.4.21 on Sun Jun 11 19:29:38 2017
*nat
:PREROUTING ACCEPT [26:1378]
:INPUT ACCEPT [21:1084]
:OUTPUT ACCEPT [72:5341]
:POSTROUTING ACCEPT [72:5341]
:DOCKER - [0:0]
-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
-A POSTROUTING -s 172.18.0.0/16 ! -o docker0 -j MASQUERADE
-A DOCKER -i docker0 -j RETURN
COMMIT
# Completed on Sun Jun 11 19:29:38 2017
# Generated by iptables-save v1.4.21 on Sun Jun 11 19:29:38 2017
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [56:8112]
-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A FORWARD -j REJECT --reject-with icmp-host-prohibited
COMMIT
# Completed on Sun Jun 11 19:29:38 2017


# Generated by iptables-save v1.4.21 on Mon Jun 12 00:22:34 2017
*nat
:PREROUTING ACCEPT [1029:73423]
:INPUT ACCEPT [233:13078]
:OUTPUT ACCEPT [942:71385]
:POSTROUTING ACCEPT [942:71385]
:DOCKER - [0:0]
-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
-A POSTROUTING -s 172.18.0.0/16 ! -o docker0 -j MASQUERADE
-A DOCKER -i docker0 -j RETURN
COMMIT
# Completed on Mon Jun 12 00:22:34 2017
# Generated by iptables-save v1.4.21 on Mon Jun 12 00:22:34 2017
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [5988:914349]
:DOCKER - [0:0]
:DOCKER-ISOLATION - [0:0]
-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A FORWARD -j DOCKER-ISOLATION
-A FORWARD -o docker0 -j DOCKER
-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -i docker0 ! -o docker0 -j ACCEPT
-A FORWARD -i docker0 -o docker0 -j ACCEPT
-A FORWARD -j REJECT --reject-with icmp-host-prohibited
-A DOCKER-ISOLATION -j RETURN
COMMIT
# Completed on Mon Jun 12 00:22:34 2017

-i eth0:从这块网卡流入的数据



docker0是一个标准Linux虚拟网桥设备


```

#### tcpdump
```
inux使用tcpdump抓包示例

每一行的各个数据表示的含义：

抓到包的时间 IP 发包的主机和端口 > 接收的主机和端口 数据包内容
监听指定的主机

$ tcpdump -i eth0 -nn 'host 192.168.1.231'
这样的话，192.168.1.231这台主机接收到的包和发送的包都会被抓取。

$ tcpdump -i eth0 -nn 'src host 192.168.1.231'
这样只有192.168.1.231这台主机发送的包才会被抓取。

$ tcpdump -i eth0 -nn 'dst host 192.168.1.231'
这样只有192.168.1.231这台主机接收到的包才会被抓取。

监听指定端口

$ tcpdump -i eth0 -nnA 'port 80'
上例是用来监听主机的80端口收到和发送的所有数据包，结合-A参数，在web开发中，真是非常有用。

监听指定主机和端口

$ tcpdump -i eth0 -nnA 'port 80 and src host 192.168.1.231'
多个条件可以用and，or连接。上例表示监听192.168.1.231主机通过80端口发送的数据包。

监听除某个端口外的其它端口

$ tcpdump -i eth0 -nnA '!port 22'
如果需要排除某个端口或者主机，可以使用“!”符号，上例表示监听非22端口的数据包。
```

#### route
```
ip route show
ip route list
route -n
ip route show table local type local

route add default gw 192.168.1.254 eth0
ip route add 192.168.1.0/24 dev eth0


route add default gw 192.168.99.254
route add -net 0.0.0.0 netmask 0.0.0.0 gw 192.168.99.254
route add -host 205.254.211.184 dev eth3
route add -net 10.38.0.0 netmask 255.255.0.0 gw 192.168.109.1
route del -host 205.254.211.184 dev eth3
route del default gw 192.168.98.254

ip route show table local
ip route show cache 192.168.100.17
ip -s route show cache 192.168.100.17  #Displaying statistics from the routing cache
ip route add 10.38.0.0/16 via 192.168.100.1

route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         192.168.1.2     0.0.0.0         UG    1024   0        0 eth0
192.168.1.0     *               255.255.255.0   U     0      0        0 eth0
This shows us how the system is currently configured. If a packet comes into the system and has a destination in the range 192.168.1.0 through 192.168.1.255, then it is forwarded to the gateway *, which is 0.0.0.0 — a special address which represents an invalid or non-existant destination. So, in this case, our system will not route these packets.
If the destination is not in this IP address range, it is forwarded to the default gateway (in this case, 192.168.1.2, and that system will determine how to forward the traffic on to the next step towards its destination.

  Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 eth0
169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0
169.254.169.254 192.168.1.1     255.255.255.255 UGH   0      0        0 eth0
192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0

Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.17.175.253  0.0.0.0         UG    0      0        0 eth0
169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0
172.17.160.0    0.0.0.0         255.255.240.0   U     0      0        0 eth0

Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.31.32.1     0.0.0.0         UG    100    0        0 eth0
172.31.32.0     0.0.0.0         255.255.240.0   U     100    0        0 eth0

Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         101.37.19.247   0.0.0.0         UG    0      0        0 eth1
10.0.0.0        10.29.115.247   255.0.0.0       UG    0      0        0 eth0
10.29.112.0     0.0.0.0         255.255.252.0   U     0      0        0 eth0
100.64.0.0      10.29.115.247   255.192.0.0     UG    0      0        0 eth0
101.37.16.0     0.0.0.0         255.255.252.0   U     0      0        0 eth1
169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0
169.254.0.0     0.0.0.0         255.255.0.0     U     1003   0        0 eth1
172.16.0.0      10.29.115.247   255.240.0.0     UG    0      0        0 eth0

匹配顺序 掩码长度，从长到短。然后Gateway是* 则表明想局域网广播。 Destination 为* 表示没有匹配到剩下IP地址。

http://linux-ip.net/html/tools-route.html

```

#### 测试网络路由
```
#添加bridge
brctl addbr bdocker
ip addr add 172.15.0.1/16 dev bdocker #设置ip 子网掩码
ip link set dev bdocker up #启动
route #多一条路由 172.15.0.0      0.0.0.0         255.255.0.0     U     0      0        0 bdocker
ifconfig # 能看到该路由。

#添加namespace
ip netns add b2
ip netns list

##添加veth1（一对）
ip link add bveth2 type veth peer name bveth2p
ip link show #会看到2条 对应的bveth2@bveth2p bveth2p@bveth2
#插入到bdocker并启动。
brctl addif bdocker bveth2
ip link set bveth2 up
brctl show #bdocker                8000.9298d2cec454       no              bveth2
#插入到另外一个b2 namespace中。
ip link set bveth2p netns b2
ip netns exec b2 ip a
ip netns exec b2 ip link set bveth2p name eth0 #重命名为eth0
ip netns exec b2 ip a
#启动b2下的eth0 并设置ip
ip netns exec b2 ip link set eth0 up
ip netns exec b2 ip addr add 172.15.0.2/16 dev eth0
ip netns exec b2 ifconfig #172.15.0.0/16 dev eth0  proto kernel  scope link  src 172.15.0.2
ip netns exec b2 route #172.15.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0
ip netns exec b2 ip route
#b2 下ping 172.15.0.1
ip netns exec b2 ping -c 3 172.15.0.1
#添加路由 来ping 其他的bridge
ip netns exec b2 ip route add default via 172.15.0.1
ip netns exec b2 ip route
#default via 172.15.0.1 dev eth0
#172.15.0.0/16 dev eth0  proto kernel  scope link  src 172.15.0.2
ip netns exec b2 ping -c 3 172.18.0.1

操作第二个ns
ip netns add b3
ip link add bveth3 type veth peer name bveth3p
brctl addif bdocker bveth3
ip link set bveth3 up
ip link set bveth3p netns b3
ip netns exec b3 ip link set bveth3p name eth0
ip netns exec b3 ip link set eth0 up
ip netns exec b3 ip addr add 172.15.0.3/16 dev eth0
ip netns exec b3 ip route add default via 172.15.0.1

#集成测试
ip netns exec b3 ping -c 3 172.15.0.1
ip netns exec b3 ping -c 3 172.18.0.1
ping 172.15.0.3
ping 172.15.0.2
ping 172.15.0.1

ip netns exec b2 ping -c 3 172.15.0.3
ip netns exec b3 ping -c 3 172.15.0.2
```
